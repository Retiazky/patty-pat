{"language":"Solidity","sources":{"src/PatGovernor.sol":{"content":"// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/governance/Governor.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorSettings.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport {console} from \"forge-std/Test.sol\";\n\ncontract PatGovernor is\n    Governor,\n    GovernorSettings,\n    GovernorCountingSimple,\n    GovernorVotes,\n    GovernorVotesQuorumFraction\n{\n    constructor(IVotes _token)\n        Governor(\"PatGovernor\")\n        GovernorSettings(0 seconds, 10 minutes, 1000e18)\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(1)\n    {}\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override returns (uint256) {\n        console.log(\"Proposing %s\", msg.sender);\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function votingDelay() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.votingDelay();\n    }\n\n    function votingPeriod() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.votingPeriod();\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(Governor, GovernorVotesQuorumFraction)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/governance/Governor.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/Governor.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\";\nimport {EIP712} from \"../utils/cryptography/EIP712.sol\";\nimport {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\nimport {SafeCast} from \"../utils/math/SafeCast.sol\";\nimport {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\";\nimport {Address} from \"../utils/Address.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {Nonces} from \"../utils/Nonces.sol\";\nimport {IGovernor, IERC6372} from \"./IGovernor.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended through various modules.\n *\n * This contract is abstract and requires several functions to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionally, {votingPeriod} must also be implemented\n */\nabstract contract Governor is Context, ERC165, EIP712, Nonces, IGovernor, IERC721Receiver, IERC1155Receiver {\n    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;\n\n    bytes32 public constant BALLOT_TYPEHASH =\n        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\n            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"\n        );\n\n    struct ProposalCore {\n        address proposer;\n        uint48 voteStart;\n        uint32 voteDuration;\n        bool executed;\n        bool canceled;\n        uint48 etaSeconds;\n    }\n\n    bytes32 private constant ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);\n    string private _name;\n\n    mapping(uint256 proposalId => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the {onlyGovernance}\n    // modifier needs to be whitelisted in this queue. Whitelisting is set in {execute}, consumed by the\n    // {onlyGovernance} modifier and eventually reset after {_executeOperations} completes. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueue.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        _checkGovernance();\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    constructor(string memory name_) EIP712(name_, version()) {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return\n            interfaceId == type(IGovernor).interfaceId ||\n            interfaceId == type(IERC1155Receiver).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState) {\n        // We read the struct fields into the stack at once so Solidity emits a single SLOAD\n        ProposalCore storage proposal = _proposals[proposalId];\n        bool proposalExecuted = proposal.executed;\n        bool proposalCanceled = proposal.canceled;\n\n        if (proposalExecuted) {\n            return ProposalState.Executed;\n        }\n\n        if (proposalCanceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert GovernorNonexistentProposal(proposalId);\n        }\n\n        uint256 currentTimepoint = clock();\n\n        if (snapshot >= currentTimepoint) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= currentTimepoint) {\n            return ProposalState.Active;\n        } else if (!_quorumReached(proposalId) || !_voteSucceeded(proposalId)) {\n            return ProposalState.Defeated;\n        } else if (proposalEta(proposalId) == 0) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].voteStart;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].voteStart + _proposals[proposalId].voteDuration;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalProposer}.\n     */\n    function proposalProposer(uint256 proposalId) public view virtual returns (address) {\n        return _proposals[proposalId].proposer;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalEta}.\n     */\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {\n        return _proposals[proposalId].etaSeconds;\n    }\n\n    /**\n     * @dev See {IGovernor-proposalNeedsQueuing}.\n     */\n    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract\n     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}\n     * operation. See {onlyGovernance}.\n     */\n    function _checkGovernance() internal virtual {\n        if (_executor() != _msgSender()) {\n            revert GovernorOnlyExecutor(_msgSender());\n        }\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.\n     */\n    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 proposerVotes = getVotes(proposer, clock() - 1);\n        uint256 votesThreshold = proposalThreshold();\n        if (proposerVotes < votesThreshold) {\n            revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }\n\n    /**\n     * @dev Internal propose mechanism. Can be overridden to add more logic on proposal creation.\n     *\n     * Emits a {IGovernor-ProposalCreated} event.\n     */\n    function _propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description,\n        address proposer\n    ) internal virtual returns (uint256 proposalId) {\n        proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {\n            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);\n        }\n        if (_proposals[proposalId].voteStart != 0) {\n            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));\n        }\n\n        uint256 snapshot = clock() + votingDelay();\n        uint256 duration = votingPeriod();\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        proposal.proposer = proposer;\n        proposal.voteStart = SafeCast.toUint48(snapshot);\n        proposal.voteDuration = SafeCast.toUint32(duration);\n\n        emit ProposalCreated(\n            proposalId,\n            proposer,\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            snapshot + duration,\n            description\n        );\n\n        // Using a named return variable to avoid stack too deep errors\n    }\n\n    /**\n     * @dev See {IGovernor-queue}.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Succeeded));\n\n        uint48 etaSeconds = _queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        if (etaSeconds != 0) {\n            _proposals[proposalId].etaSeconds = etaSeconds;\n            emit ProposalQueued(proposalId, etaSeconds);\n        } else {\n            revert GovernorQueueNotImplemented();\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal queuing mechanism. Can be overridden (without a super call) to modify the way queuing is\n     * performed (for example adding a vault/timelock).\n     *\n     * This is empty by default, and must be overridden to implement queuing.\n     *\n     * This function returns a timestamp that describes the expected ETA for execution. If the returned value is 0\n     * (which is the default value), the core will consider queueing did not succeed, and the public {queue} function\n     * will revert.\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, or emit the\n     * `ProposalQueued` event. Queuing a proposal should be done using {queue}.\n     */\n    function _queueOperations(\n        uint256 /*proposalId*/,\n        address[] memory /*targets*/,\n        uint256[] memory /*values*/,\n        bytes[] memory /*calldatas*/,\n        bytes32 /*descriptionHash*/\n    ) internal virtual returns (uint48) {\n        return 0;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)\n        );\n\n        // mark as executed before calls to avoid reentrancy\n        _proposals[proposalId].executed = true;\n\n        // before execute: register governance call in queue.\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n\n        _executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n\n        // after execute: cleanup governance call queue.\n        if (_executor() != address(this) && !_governanceCall.empty()) {\n            _governanceCall.clear();\n        }\n\n        emit ProposalExecuted(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden (without a super call) to modify the way execution is\n     * performed (for example adding a vault/timelock).\n     *\n     * NOTE: Calling this function directly will NOT check the current state of the proposal, set the executed flag to\n     * true or emit the `ProposalExecuted` event. Executing a proposal should be done using {execute} or {_execute}.\n     */\n    function _executeOperations(\n        uint256 /* proposalId */,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            Address.verifyCallResult(success, returndata);\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-cancel}.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256) {\n        // The proposalId will be recomputed in the `_cancel` call further down. However we need the value before we\n        // do the internal call, because we need to check the proposal state BEFORE the internal `_cancel` call\n        // changes it. The `hashProposal` duplication has a cost that is limited, and that we accept.\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        // public cancel restrictions (on top of existing _cancel restrictions).\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Pending));\n        if (_msgSender() != proposalProposer(proposalId)) {\n            revert GovernorOnlyProposer(_msgSender());\n        }\n\n        return _cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    /**\n     * @dev Internal cancel mechanism with minimal restrictions. A proposal can be cancelled in any state other than\n     * Canceled, Expired, or Executed. Once cancelled a proposal can't be re-submitted.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        _validateStateBitmap(\n            proposalId,\n            ALL_PROPOSAL_STATES_BITMAP ^\n                _encodeStateBitmap(ProposalState.Canceled) ^\n                _encodeStateBitmap(ProposalState.Expired) ^\n                _encodeStateBitmap(ProposalState.Executed)\n        );\n\n        _proposals[proposalId].canceled = true;\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) public view virtual returns (uint256) {\n        return _getVotes(account, timepoint, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        bool valid = SignatureChecker.isValidSignatureNow(\n            voter,\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),\n            signature\n        );\n\n        if (!valid) {\n            revert GovernorInvalidSignature(voter);\n        }\n\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) public virtual returns (uint256) {\n        bool valid = SignatureChecker.isValidSignatureNow(\n            voter,\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        voter,\n                        _useNonce(voter),\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            signature\n        );\n\n        if (!valid) {\n            revert GovernorInvalidSignature(voter);\n        }\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        _validateStateBitmap(proposalId, _encodeStateBitmap(ProposalState.Active));\n\n        uint256 weight = _getVotes(account, proposalSnapshot(proposalId), params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(address target, uint256 value, bytes calldata data) external payable virtual onlyGovernance {\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        Address.verifyCallResult(success, returndata);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (_executor() != address(this)) {\n            revert GovernorDisabledDeposit();\n        }\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to\n     * the underlying position in the `ProposalState` enum. For example:\n     *\n     * 0x000...10000\n     *   ^^^^^^------ ...\n     *         ^----- Succeeded\n     *          ^---- Defeated\n     *           ^--- Canceled\n     *            ^-- Active\n     *             ^- Pending\n     */\n    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {\n        return bytes32(1 << uint8(proposalState));\n    }\n\n    /**\n     * @dev Check that the current state of a proposal matches the requirements described by the `allowedStates` bitmap.\n     * This bitmap should be built using `_encodeStateBitmap`.\n     *\n     * If requirements are not met, reverts with a {GovernorUnexpectedProposalState} error.\n     */\n    function _validateStateBitmap(uint256 proposalId, bytes32 allowedStates) private view returns (ProposalState) {\n        ProposalState currentState = state(proposalId);\n        if (_encodeStateBitmap(currentState) & allowedStates == bytes32(0)) {\n            revert GovernorUnexpectedProposalState(proposalId, currentState, allowedStates);\n        }\n        return currentState;\n    }\n\n    /*\n     * @dev Check if the proposer is authorized to submit a proposal with the given description.\n     *\n     * If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string\n     * (case insensitive), then the submission of this proposal will only be authorized to said address.\n     *\n     * This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure\n     * that no other address can submit the same proposal. An attacker would have to either remove or change that part,\n     * which would result in a different proposal id.\n     *\n     * If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:\n     * - If the `0x???` part is not a valid hex string.\n     * - If the `0x???` part is a valid hex string, but does not contain exactly 40 hex digits.\n     * - If it ends with the expected suffix followed by newlines or other whitespace.\n     * - If it ends with some other similar suffix, e.g. `#other=abc`.\n     * - If it does not end with any such suffix.\n     */\n    function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        uint256 len = bytes(description).length;\n\n        // Length is too short to contain a valid proposer suffix\n        if (len < 52) {\n            return true;\n        }\n\n        // Extract what would be the `#proposer=0x` marker beginning the suffix\n        bytes12 marker;\n        assembly {\n            // - Start of the string contents in memory = description + 32\n            // - First character of the marker = len - 52\n            //   - Length of \"#proposer=0x0000000000000000000000000000000000000000\" = 52\n            // - We read the memory word starting at the first character of the marker:\n            //   - (description + 32) + (len - 52) = description + (len - 20)\n            // - Note: Solidity will ignore anything past the first 12 bytes\n            marker := mload(add(description, sub(len, 20)))\n        }\n\n        // If the marker is not found, there is no proposer suffix to check\n        if (marker != bytes12(\"#proposer=0x\")) {\n            return true;\n        }\n\n        // Parse the 40 characters following the marker as uint160\n        uint160 recovered = 0;\n        for (uint256 i = len - 40; i < len; ++i) {\n            (bool isHex, uint8 value) = _tryHexToUint(bytes(description)[i]);\n            // If any of the characters is not a hex digit, ignore the suffix entirely\n            if (!isHex) {\n                return true;\n            }\n            recovered = (recovered << 4) | value;\n        }\n\n        return recovered == uint160(proposer);\n    }\n\n    /**\n     * @dev Try to parse a character from a string as a hex value. Returns `(true, value)` if the char is in\n     * `[0-9a-fA-F]` and `(false, 0)` otherwise. Value is guaranteed to be in the range `0 <= value < 16`\n     */\n    function _tryHexToUint(bytes1 char) private pure returns (bool, uint8) {\n        uint8 c = uint8(char);\n        unchecked {\n            // Case 0-9\n            if (47 < c && c < 58) {\n                return (true, c - 48);\n            }\n            // Case A-F\n            else if (64 < c && c < 71) {\n                return (true, c - 55);\n            }\n            // Case a-f\n            else if (96 < c && c < 103) {\n                return (true, c - 87);\n            }\n            // Else: not a hex char\n            else {\n                return (false, 0);\n            }\n        }\n    }\n\n    /**\n     * @inheritdoc IERC6372\n     */\n    function clock() public view virtual returns (uint48);\n\n    /**\n     * @inheritdoc IERC6372\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory);\n\n    /**\n     * @inheritdoc IGovernor\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IGovernor\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @inheritdoc IGovernor\n     */\n    function quorum(uint256 timepoint) public view virtual returns (uint256);\n}\n"},"lib/openzeppelin-contracts/contracts/governance/extensions/GovernorSettings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Governor} from \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n */\nabstract contract GovernorSettings is Governor {\n    // amount of token\n    uint256 private _proposalThreshold;\n    // timepoint: limited to uint48 in core (same as clock() type)\n    uint48 private _votingDelay;\n    // duration: limited to uint32 in core\n    uint32 private _votingPeriod;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    constructor(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint48 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {\n        if (newVotingPeriod == 0) {\n            revert GovernorInvalidVotingPeriod(0);\n        }\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/governance/extensions/GovernorCountingSimple.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.20;\n\nimport {Governor} from \"../Governor.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n */\nabstract contract GovernorCountingSimple is Governor {\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address voter => bool) hasVoted;\n    }\n\n    mapping(uint256 proposalId => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(\n        uint256 proposalId\n    ) public view virtual returns (uint256 againstVotes, uint256 forVotes, uint256 abstainVotes) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n        return (proposalVote.againstVotes, proposalVote.forVotes, proposalVote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalVote.forVotes + proposalVote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        return proposalVote.forVotes > proposalVote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalVote = _proposalVotes[proposalId];\n\n        if (proposalVote.hasVoted[account]) {\n            revert GovernorAlreadyCastVote(account);\n        }\n        proposalVote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalVote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalVote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalVote.abstainVotes += weight;\n        } else {\n            revert GovernorInvalidVoteType();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/governance/extensions/GovernorVotes.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.20;\n\nimport {Governor} from \"../Governor.sol\";\nimport {IVotes} from \"../utils/IVotes.sol\";\nimport {IERC5805} from \"../../interfaces/IERC5805.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes}\n * token.\n */\nabstract contract GovernorVotes is Governor {\n    IERC5805 private immutable _token;\n\n    constructor(IVotes tokenAddress) {\n        _token = IERC5805(address(tokenAddress));\n    }\n\n    /**\n     * @dev The token that voting power is sourced from.\n     */\n    function token() public view virtual returns (IERC5805) {\n        return _token;\n    }\n\n    /**\n     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token\n     * does not implement EIP-6372.\n     */\n    function clock() public view virtual override returns (uint48) {\n        try token().clock() returns (uint48 timepoint) {\n            return timepoint;\n        } catch {\n            return Time.blockNumber();\n        }\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual override returns (string memory) {\n        try token().CLOCK_MODE() returns (string memory clockmode) {\n            return clockmode;\n        } catch {\n            return \"mode=blocknumber&from=default\";\n        }\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 timepoint,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token().getPastVotes(account, timepoint);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/governance/extensions/GovernorVotesQuorumFraction.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.20;\n\nimport {GovernorVotes} from \"./GovernorVotes.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {Checkpoints} from \"../../utils/structs/Checkpoints.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n */\nabstract contract GovernorVotesQuorumFraction is GovernorVotes {\n    using Checkpoints for Checkpoints.Trace208;\n\n    Checkpoints.Trace208 private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev The quorum set is not a valid fraction.\n     */\n    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    constructor(uint256 quorumNumeratorValue) {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n\n        // Optimistic search, check the latest checkpoint\n        Checkpoints.Checkpoint208 storage latest = _quorumNumeratorHistory._checkpoints[length - 1];\n        uint48 latestKey = latest._key;\n        uint208 latestValue = latest._value;\n        if (latestKey <= timepoint) {\n            return latestValue;\n        }\n\n        // Otherwise, do the binary search\n        return _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 timepoint) public view virtual override returns (uint256) {\n        return (token().getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        uint256 denominator = quorumDenominator();\n        if (newQuorumNumerator > denominator) {\n            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);\n        }\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n        _quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n}\n"},"lib/forge-std/src/Test.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// 💬 ABOUT\n// Forge Std's default Test.\n\n// 🧩 MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {stdToml} from \"./StdToml.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n// 📦 BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\n\n// ⭐️ TEST\nabstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n    // Note: IS_TEST() must return true.\n    bool public IS_TEST = true;\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.20;\n\nimport {ECDSA} from \"./ECDSA.sol\";\nimport {IERC1271} from \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Safe Wallet (previously Gnosis Safe).\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/DoubleEndedQueue.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```solidity\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n */\nlibrary DoubleEndedQueue {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error QueueEmpty();\n\n    /**\n     * @dev A push operation couldn't be completed due to the queue being full.\n     */\n    error QueueFull();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error QueueOutOfBounds();\n\n    /**\n     * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\n     */\n    struct Bytes32Deque {\n        uint128 _begin;\n        uint128 _end;\n        mapping(uint128 index => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     *\n     * Reverts with {QueueFull} if the queue is full.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex + 1 == deque._begin) revert QueueFull();\n            deque._data[backIndex] = value;\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with {QueueEmpty} if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 backIndex = deque._end;\n            if (backIndex == deque._begin) revert QueueEmpty();\n            --backIndex;\n            value = deque._data[backIndex];\n            delete deque._data[backIndex];\n            deque._end = backIndex;\n        }\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     *\n     * Reverts with {QueueFull} if the queue is full.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        unchecked {\n            uint128 frontIndex = deque._begin - 1;\n            if (frontIndex == deque._end) revert QueueFull();\n            deque._data[frontIndex] = value;\n            deque._begin = frontIndex;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `QueueEmpty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        unchecked {\n            uint128 frontIndex = deque._begin;\n            if (frontIndex == deque._end) revert QueueEmpty();\n            value = deque._data[frontIndex];\n            delete deque._data[frontIndex];\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `QueueEmpty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert QueueEmpty();\n        return deque._data[deque._begin];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `QueueEmpty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert QueueEmpty();\n        unchecked {\n            return deque._data[deque._end - 1];\n        }\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `QueueOutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        if (index >= length(deque)) revert QueueOutOfBounds();\n        // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\n        unchecked {\n            return deque._data[deque._begin + uint128(index)];\n        }\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        unchecked {\n            return uint256(deque._end - deque._begin);\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end == deque._begin;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Nonces.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/governance/IGovernor.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/IGovernor.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../interfaces/IERC165.sol\";\nimport {IERC6372} from \"../interfaces/IERC6372.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n */\ninterface IGovernor is IERC165, IERC6372 {\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.\n     */\n    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);\n\n    /**\n     * @dev The vote was already cast.\n     */\n    error GovernorAlreadyCastVote(address voter);\n\n    /**\n     * @dev Token deposits are disabled in this contract.\n     */\n    error GovernorDisabledDeposit();\n\n    /**\n     * @dev The `account` is not a proposer.\n     */\n    error GovernorOnlyProposer(address account);\n\n    /**\n     * @dev The `account` is not the governance executor.\n     */\n    error GovernorOnlyExecutor(address account);\n\n    /**\n     * @dev The `proposalId` doesn't exist.\n     */\n    error GovernorNonexistentProposal(uint256 proposalId);\n\n    /**\n     * @dev The current state of a proposal is not the required for performing an operation.\n     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position\n     * counting from right to left.\n     *\n     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).\n     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).\n     *\n     * See {Governor-_encodeStateBitmap}.\n     */\n    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);\n\n    /**\n     * @dev The voting period set is not a valid period.\n     */\n    error GovernorInvalidVotingPeriod(uint256 votingPeriod);\n\n    /**\n     * @dev The `proposer` does not have the required votes to create a proposal.\n     */\n    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);\n\n    /**\n     * @dev The `proposer` is not allowed to create a proposal.\n     */\n    error GovernorRestrictedProposer(address proposer);\n\n    /**\n     * @dev The vote type used is not valid for the corresponding counting module.\n     */\n    error GovernorInvalidVoteType();\n\n    /**\n     * @dev Queue operation is not implemented for this governor. Execute should be called directly.\n     */\n    error GovernorQueueNotImplemented();\n\n    /**\n     * @dev The proposal hasn't been queued yet.\n     */\n    error GovernorNotQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The proposal has already been queued.\n     */\n    error GovernorAlreadyQueuedProposal(uint256 proposalId);\n\n    /**\n     * @dev The provided signature is not valid for the expected `voter`.\n     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.\n     */\n    error GovernorInvalidSignature(address voter);\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 voteStart,\n        uint256 voteEnd,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is queued.\n     */\n    event ProposalQueued(uint256 proposalId, uint256 etaSeconds);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their interpepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() external view returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() external view returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external pure returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) external view returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev The number of votes required in order for a voter to become a proposer.\n     */\n    function proposalThreshold() external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the\n     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the\n     * following block.\n     */\n    function proposalSnapshot(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is\n     * possible to cast a vote during this block.\n     */\n    function proposalDeadline(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev The account that created a proposal.\n     */\n    function proposalProposer(uint256 proposalId) external view returns (address);\n\n    /**\n     * @notice module:core\n     * @dev The time when a queued proposal becomes executable (\"ETA\"). Unlike {proposalSnapshot} and\n     * {proposalDeadline}, this doesn't use the governor clock, and instead relies on the executor's clock which may be\n     * different. In most cases this will be a timestamp.\n     */\n    function proposalEta(uint256 proposalId) external view returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Whether a proposal needs to be queued before execution.\n     */\n    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends\n     * on the clock (see EIP-6372) this contract uses.\n     *\n     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a\n     * proposal starts.\n     *\n     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.\n     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.\n     */\n    function votingDelay() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock\n     * (see EIP-6372) this contract uses.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     *\n     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect\n     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this\n     * interface returns a uint256, the value it returns should fit in a uint32.\n     */\n    function votingPeriod() external view returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).\n     */\n    function quorum(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 timepoint,\n        bytes memory params\n    ) external view returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns whether `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) external view returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a\n     * duration specified by {IGovernor-votingPeriod}.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing\n     * is not necessary, this function may revert.\n     * Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.\n     *\n     * Emits a {ProposalQueued} event.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached. Depending on the governor it might also be required that the proposal was queued and\n     * that some delay passed.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * NOTE: Some modules can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external payable returns (uint256 proposalId);\n\n    /**\n     * @dev Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e.\n     * before the vote starts.\n     *\n     * Emits a {ProposalCanceled} event.\n     */\n    function cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) external returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        bytes memory signature\n    ) external returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,\n     * including ERC-1271 signature support.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        address voter,\n        string calldata reason,\n        bytes memory params,\n        bytes memory signature\n    ) external returns (uint256 balance);\n}\n"},"lib/openzeppelin-contracts/contracts/governance/utils/IVotes.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC5805.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.20;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"},"lib/openzeppelin-contracts/contracts/utils/types/Time.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/Checkpoints.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"},"lib/forge-std/src/console.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"},"lib/forge-std/src/console2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _castLogPayloadViewToPure(\n        function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"},"lib/forge-std/src/safeconsole.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `logBytes(bytes)`.\n                mstore(sub(offset, 0x60), 0xe17bf956)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            assembly {\n                // Selector of `logBytes(bytes)`.\n                mstore(add(offset, 0x00), 0xe17bf956)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"},"lib/forge-std/src/StdAssertions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdAssertions {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    bool private _failed;\n\n    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n    }\n\n    function fail() internal virtual {\n        vm.store(address(vm), bytes32(\"failed\"), bytes32(uint256(1)));\n        _failed = true;\n    }\n\n    function assertTrue(bool data) internal pure virtual {\n        vm.assertTrue(data);\n    }\n\n    function assertTrue(bool data, string memory err) internal pure virtual {\n        vm.assertTrue(data, err);\n    }\n\n    function assertFalse(bool data) internal pure virtual {\n        vm.assertFalse(data);\n    }\n\n    function assertFalse(bool data, string memory err) internal pure virtual {\n        vm.assertFalse(data, err);\n    }\n\n    function assertEq(bool left, bool right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(int256 left, int256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(address left, address right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertEq(string memory left, string memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 left, uint256 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(int256 left, int256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(address left, address right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string memory left, string memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertLt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertLt(int256 left, int256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(int256 left, int256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(int256 left, int256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(int256 left, int256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    // Inherited from DSTest, not used but kept for backwards-compatibility\n    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {\n        return keccak256(left) == keccak256(right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n    }\n}\n"},"lib/forge-std/src/StdChains.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\n        private\n        view\n        returns (Chain memory)\n    {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // Distinguish 'not found' from 'cannot read'\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\n                bytes memory oldNotFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                bytes memory newNotFoundError = abi.encodeWithSignature(\n                    \"CheatcodeError(string)\", string(abi.encodePacked(\"invalid rpc url: \", chainAlias))\n                );\n                bytes32 errHash = keccak256(err);\n                if (\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\n                        || bytes(chain.rpcUrl).length == 0\n                ) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"holesky\", ChainData(\"Holesky\", 17000, \"https://rpc.holesky.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\n            \"optimism_sepolia\", ChainData(\"Optimism Sepolia\", 11155420, \"https://sepolia.optimism.io\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_sepolia\", ChainData(\"Arbitrum One Sepolia\", 421614, \"https://sepolia-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_amoy\", ChainData(\"Polygon Amoy\", 80002, \"https://rpc-amoy.polygon.technology\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_sepolia\", ChainData(\"Base Sepolia\", 84532, \"https://sepolia.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n        setChainWithDefaultRpcUrl(\"fraxtal\", ChainData(\"Fraxtal\", 252, \"https://rpc.frax.com\"));\n        setChainWithDefaultRpcUrl(\"fraxtal_testnet\", ChainData(\"Fraxtal Testnet\", 2522, \"https://rpc.testnet.frax.com\"));\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"},"lib/forge-std/src/StdCheats.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which has already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These should be present on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0x9));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log_StdCheats(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n"},"lib/forge-std/src/StdError.sol":{"content":"// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"},"lib/forge-std/src/StdInvariant.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzArtifactSelector {\n        string artifact;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzArtifactSelector[] private _targetedArtifactSelectors;\n\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\n        _targetedInterfaces.push(newTargetedInterface_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n}\n"},"lib/forge-std/src/StdJson.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"},"lib/forge-std/src/StdMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"},"lib/forge-std/src/StdStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cald);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n        (bool success, bytes32 prevReturnValue) = callTarget(self);\n\n        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);\n        vm.store(self._target, slot, testVal);\n\n        (, bytes32 newReturnValue) = callTarget(self);\n\n        vm.store(self._target, slot, prevSlotValue);\n\n        return (success && (prevReturnValue != newReturnValue));\n    }\n\n    // Tries setting one of the bits in slot to 1 until return value changes.\n    // Index of resulted bit is an offset packed slot has from left/right side\n    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {\n        for (uint256 offset = 0; offset < 256; offset++) {\n            uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);\n            vm.store(self._target, slot, bytes32(valueToPut));\n\n            (bool success, bytes32 data) = callTarget(self);\n\n            if (success && (uint256(data) > 0)) {\n                return (true, offset);\n            }\n        }\n        return (false, 0);\n    }\n\n    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n\n        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);\n        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);\n\n        // `findOffset` may mutate slot value, so we are setting it to initial value\n        vm.store(self._target, slot, prevSlotValue);\n        return (foundLeft && foundRight, offsetLeft, offsetRight);\n    }\n\n    function find(StdStorage storage self) internal returns (FindData storage) {\n        return find(self, true);\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = getCallParams(self);\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            if (_clear) {\n                clear(self);\n            }\n            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        }\n        vm.record();\n        (, bytes32 callResult) = callTarget(self);\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n\n        if (reads.length == 0) {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        } else {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n\n                if (!checkSlotMutatesCall(self, reads[i])) {\n                    continue;\n                }\n\n                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);\n\n                if (self._enable_packed_slots) {\n                    bool found;\n                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);\n                    if (!found) {\n                        continue;\n                    }\n                }\n\n                // Check that value between found offsets is equal to the current call result\n                uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;\n\n                if (uint256(callResult) != curVal) {\n                    continue;\n                }\n\n                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));\n                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =\n                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);\n                break;\n            }\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        if (_clear) {\n            clear(self);\n        }\n        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        self._calldata = _calldata;\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        self._enable_packed_slots = true;\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        FindData storage data = find(self, false);\n        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);\n        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;\n        clear(self);\n        return abi.encode(value);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n    function clear(StdStorage storage self) internal {\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n        delete self._enable_packed_slots;\n        delete self._calldata;\n    }\n\n    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`\n    // (slotValue & mask) >> offsetRight will be the value of the given packed variable\n    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {\n        // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;\n        // using assembly because (1 << 256) causes overflow\n        assembly {\n            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))\n        }\n    }\n\n    // Returns slot value with updated packed variable.\n    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)\n        internal\n        pure\n        returns (bytes32 newValue)\n    {\n        return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return find(self, true);\n    }\n\n    function find(StdStorage storage self, bool _clear) internal returns (uint256) {\n        return stdStorageSafe.find(self, _clear).slot;\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_calldata(self, _calldata);\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        return stdStorageSafe.enable_packed_slots(self);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function clear(StdStorage storage self) internal {\n        stdStorageSafe.clear(self);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = stdStorageSafe.getCallParams(self);\n\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            find(self, false);\n        }\n        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        if ((data.offsetLeft + data.offsetRight) > 0) {\n            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));\n            require(\n                uint256(set) < maxVal,\n                string(\n                    abi.encodePacked(\n                        \"stdStorage find(StdStorage): Packed slot. We can't fit value greater than \",\n                        vm.toString(maxVal)\n                    )\n                )\n            );\n        }\n        bytes32 curVal = vm.load(who, bytes32(data.slot));\n        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);\n\n        vm.store(who, bytes32(data.slot), valToSet);\n\n        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);\n\n        if (!success || callResult != set) {\n            vm.store(who, bytes32(data.slot), curVal);\n            revert(\"stdStorage find(StdStorage): Failed to write value.\");\n        }\n        clear(self);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n}\n"},"lib/forge-std/src/StdStyle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"},"lib/forge-std/src/StdToml.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing TOML files\n// To parse:\n// ```\n// using stdToml for string;\n// string memory toml = vm.readFile(\"<some_path>\");\n// toml.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdToml for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdToml {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseToml(toml, key);\n    }\n\n    function readUint(string memory toml, string memory key) internal pure returns (uint256) {\n        return vm.parseTomlUint(toml, key);\n    }\n\n    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseTomlUintArray(toml, key);\n    }\n\n    function readInt(string memory toml, string memory key) internal pure returns (int256) {\n        return vm.parseTomlInt(toml, key);\n    }\n\n    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseTomlIntArray(toml, key);\n    }\n\n    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {\n        return vm.parseTomlBytes32(toml, key);\n    }\n\n    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseTomlBytes32Array(toml, key);\n    }\n\n    function readString(string memory toml, string memory key) internal pure returns (string memory) {\n        return vm.parseTomlString(toml, key);\n    }\n\n    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {\n        return vm.parseTomlStringArray(toml, key);\n    }\n\n    function readAddress(string memory toml, string memory key) internal pure returns (address) {\n        return vm.parseTomlAddress(toml, key);\n    }\n\n    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {\n        return vm.parseTomlAddressArray(toml, key);\n    }\n\n    function readBool(string memory toml, string memory key) internal pure returns (bool) {\n        return vm.parseTomlBool(toml, key);\n    }\n\n    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseTomlBoolArray(toml, key);\n    }\n\n    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseTomlBytes(toml, key);\n    }\n\n    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseTomlBytesArray(toml, key);\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeToml(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeToml(jsonKey, path, valueKey);\n    }\n}\n"},"lib/forge-std/src/StdUtils.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {MockERC20} from \"./mocks/MockERC20.sol\";\nimport {MockERC721} from \"./mocks/MockERC721.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        console2_log_StdUtils(\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\");\n        return vm.computeCreateAddress(deployer, nonce);\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initCodeHash);\n    }\n\n    /// @dev returns an initialized mock ERC20 contract\n    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)\n        internal\n        returns (MockERC20 mock)\n    {\n        mock = new MockERC20();\n        mock.initialize(name, symbol, decimals);\n    }\n\n    /// @dev returns an initialized mock ERC721 contract\n    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {\n        mock = new MockERC721();\n        mock.initialize(name, symbol);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\n    // any breaking changes to function signatures.\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\n        internal\n        pure\n        returns (function(bytes memory) internal pure fnOut)\n    {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE2_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function console2_log_StdUtils(string memory p0) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n}\n"},"lib/forge-std/src/Vm.sol":{"content":"// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // The amount of gas used for memory expansion.\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(string calldata name) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        view\n        returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        view\n        returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        view\n        returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        view\n        returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        view\n        returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        view\n        returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        view\n        returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(ForgeContext context) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\n        external\n        returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Gets the gas used in the last call.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(string calldata promptText) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Scripting ========\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    // ======== String ========\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(string calldata input, string calldata key) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(string calldata input, string calldata from, string calldata to)\n        external\n        pure\n        returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(string calldata input) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(address value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(string calldata input) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(string calldata input) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external;\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(string calldata toml, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(string calldata toml, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\n        external\n        pure\n        returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(address account) external view returns (string memory currentLabel);\n\n    /// Get a `Wallet`'s nonce.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Signs data with a `Wallet`.\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(string calldata data) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(string calldata data) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(address account) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory revm state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1, address account2) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertTo`.\n    function snapshot() external returns (uint256 snapshotId);\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) ∪ [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top of the test.\n    function skip(bool skipTest) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"},"lib/forge-std/src/Base.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/cryptography/MessageHashUtils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/ShortStrings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC5267.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"},"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"lib/openzeppelin-contracts/contracts/interfaces/IERC6372.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"},"lib/forge-std/src/interfaces/IMulticall3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"},"lib/forge-std/src/mocks/MockERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol\ncontract MockERC20 is IERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal _totalSupply;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    mapping(address => mapping(address => uint256)) internal _allowance;\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal INITIAL_CHAIN_ID;\n\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n\n        INITIAL_CHAIN_ID = _pureChainId();\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);\n\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n        virtual\n    {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        address recoveredAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                            ),\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n        _allowance[recoveredAddress][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(_name)),\n                keccak256(\"1\"),\n                _pureChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply = _add(_totalSupply, amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _totalSupply = _sub(_totalSupply, amount);\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MATH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERC20: addition overflow\");\n        return c;\n    }\n\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b, \"ERC20: subtraction underflow\");\n        return a - b;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n"},"lib/forge-std/src/mocks/MockERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC721Metadata} from \"../interfaces/IERC721.sol\";\n\n/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol\ncontract MockERC721 is IERC721Metadata {\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {}\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual override returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function getApproved(uint256 id) public view virtual override returns (address) {\n        return _getApproved[id];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public payable virtual override {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        _getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public payable virtual override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        _balanceOf[from]--;\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        delete _getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)\n        public\n        payable\n        virtual\n        override\n    {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        _balanceOf[owner]--;\n\n        delete _ownerOf[id];\n\n        delete _getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _isContract(address _addr) private view returns (bool) {\n        uint256 codeLength;\n\n        // Assembly required for versions < 0.8.0 to check extcodesize.\n        assembly {\n            codeLength := extcodesize(_addr)\n        }\n\n        return codeLength > 0;\n    }\n}\n\ninterface IERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"},"lib/forge-std/src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"},"lib/forge-std/src/interfaces/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"},"lib/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@v4-core/=lib/v4-core/src/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
